mod biome;
mod config;
mod executor;

use biome::{init_biome_config, BiomeRunner};
use clap::{Parser, Subcommand};
use config::Config;
use executor::HookExecutor;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::process;

#[derive(Parser)]
#[command(name = "astrape")]
#[command(version, about = "âš¡ Lightning-fast Rust-native git hooks manager", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Init {
        #[arg(short, long, default_value = "astrape.yml")]
        config: String,
    },
    Install,
    Run {
        hook: String,
    },
    Check {
        #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
        files: Vec<String>,
    },
    Fix {
        #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
        files: Vec<String>,
    },
}

fn main() {
    let cli = Cli::parse();

    let result = match cli.command {
        Commands::Init { config } => init_command(&config),
        Commands::Install => install_command(),
        Commands::Run { hook } => run_command(&hook),
        Commands::Check { files } => check_command(&files),
        Commands::Fix { files } => fix_command(&files),
    };

    if let Err(e) = result {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}

fn init_command(config_path: &str) -> anyhow::Result<()> {
    println!("âš¡ Initializing astrape...\n");

    let mut created_files = Vec::new();

    if !std::path::Path::new(config_path).exists() {
        let config = Config::default_config();
        let yaml = config.to_yaml()?;
        fs::write(config_path, yaml)?;
        created_files.push(config_path.to_string());
    }

    if init_biome_config()? {
        created_files.push("biome.json".to_string());
    }

    if created_files.is_empty() {
        println!("â„¹ï¸  All config files already exist");
    } else {
        println!("âœ… Created:");
        for file in &created_files {
            println!("   â€¢ {}", file);
        }
    }

    println!("\nðŸ“¦ Next steps:");
    println!("   1. Run: astrape install");
    println!("   2. Commit normally - hooks will run automatically");

    Ok(())
}

fn install_command() -> anyhow::Result<()> {
    println!("ðŸ“¦ Installing git hooks...\n");

    let git_dir = find_git_dir()?;
    let hooks_dir = git_dir.join("hooks");

    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir)?;
    }

    let config_path = "astrape.yml";
    if !Path::new(config_path).exists() {
        anyhow::bail!(
            "Config file not found: {}. Run 'astrape init' first.",
            config_path
        );
    }

    let config = Config::from_file(config_path)?;
    let mut installed_hooks = Vec::new();

    for hook_name in config.hooks.keys() {
        let hook_path = hooks_dir.join(hook_name);
        let hook_script = generate_hook_script(hook_name);

        if hook_path.exists() {
            let existing = fs::read_to_string(&hook_path)?;
            if !existing.contains("# astrape managed hook") {
                let backup_path = hooks_dir.join(format!("{}.backup", hook_name));
                fs::rename(&hook_path, &backup_path)?;
                println!(
                    "   âš ï¸  Backed up existing {} to {}.backup",
                    hook_name, hook_name
                );
            }
        }

        fs::write(&hook_path, hook_script)?;

        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms)?;

        installed_hooks.push(hook_name.clone());
    }

    if installed_hooks.is_empty() {
        println!("â„¹ï¸  No hooks defined in config");
    } else {
        println!("âœ… Installed hooks:");
        for hook in &installed_hooks {
            println!("   â€¢ {}", hook);
        }
    }

    println!("\nðŸŽ‰ Done! Git hooks are now active.");
    Ok(())
}

fn find_git_dir() -> anyhow::Result<std::path::PathBuf> {
    let current = std::env::current_dir()?;
    let mut path = current.as_path();

    loop {
        let git_dir = path.join(".git");
        if git_dir.is_dir() {
            return Ok(git_dir);
        }

        match path.parent() {
            Some(parent) => path = parent,
            None => anyhow::bail!("Not a git repository (or any parent up to mount point)"),
        }
    }
}

fn generate_hook_script(hook_name: &str) -> String {
    format!(
        r#"#!/bin/sh
# astrape managed hook - do not edit
# This hook was generated by astrape. To modify, edit astrape.yml

exec astrape run {}
"#,
        hook_name
    )
}

fn run_command(hook_name: &str) -> anyhow::Result<()> {
    let config_path = "astrape.yml";

    if !std::path::Path::new(config_path).exists() {
        anyhow::bail!(
            "Config file not found: {}. Run 'astrape init' first.",
            config_path
        );
    }

    let config = Config::from_file(config_path)?;

    let hook_config = config
        .hooks
        .get(hook_name)
        .ok_or_else(|| anyhow::anyhow!("Hook '{}' not found in config", hook_name))?;

    let executor = HookExecutor::new(hook_name.to_string());
    executor.execute(hook_config)?;

    println!("\nâœ… Hook '{}' completed successfully", hook_name);
    Ok(())
}

fn check_command(files: &[String]) -> anyhow::Result<()> {
    let runner = BiomeRunner::new();
    runner.check(files)
}

fn fix_command(files: &[String]) -> anyhow::Result<()> {
    let runner = BiomeRunner::new();
    runner.fix(files)
}
